from ply import yacc
from typing import Optional, List

# LEXER / TOKENS
from ..lexer.tokens import TOKENS

# print(TOKENS)
from ..lexer.lexer import Lexer



tokens = TOKENS  # tuple of tokens defined in the lexer

# AST NODES
from ..core.ast import (
    AstNode,
    LiteralExpr,
    Identifier,
    UnaryExpr,
    BinaryExpr,
    ComparisonExpr,
    CallExpr,
    
    TupleExpr,
    ListExpr,
    DictExpr,

    FunctionDef,
    ClassDef,
    ExprStmt,
    Pass,
    Assign,
    Return,
    Block,
    Break,
    Continue,
    If,
    While,
    For,
    Module,

)

from ..core.utils import Error

# PRECEDENCE
precedence = (
    ("left", "OR"),  # lowest
    ("left", "AND"),
    (
        "left",
        "EQUALS",
        "NOT_EQUALS",
        "LESS_THAN",
        "LESS_THAN_EQUALS",
        "GREATER_THAN",
        "GREATER_THAN_EQUALS",
    ),
    ("left", "PLUS", "MINUS"),
    ("left", "TIMES", "DIVIDE", "FLOOR_DIVIDE", "MOD"),
    ("right", "UPLUS", "UMINUS", "NOT"),
    ("right", "POWER"),  # highest
)


def _pos(p, i) -> tuple[int, int]:
    """Returns approximate (line, col) for the i-th symbol of the production."""
    return p.lineno(i), p.lexpos(i)


class Parser:
    """
    Implementation of the parser.
    It takes the source code tokenized by the lexer and converts it into an
    Abstract Syntax Tree(AST) that represents the structure of the code according to
    the defined grammatical rules. The parser uses PLY (Python Lex-Yacc) to build
    the tree from the tokens generated by the lexer.

    - Syntactically analyze language expressions and generate the corresponding AST.
    - Implement operator precedence rules and ensure that expressions are evaluated correctly.

    """

    tokens = TOKENS
    precedence = precedence

    def __init__(self, debug: bool = False):
        self.debug = debug
        self.errors: List[Error] = []
        self.data: Optional[str] = None

        # Lexer
        self.lexer = Lexer(errors=self.errors, debug=self.debug)
        self.lexer.build()

        self._parser = yacc.yacc(module=self, start="module", debug=self.debug)

    def parse(
        self, text: str
    ) -> (
        AstNode
    ):  # This function receives text and passes it to the lexer for tokenization.
        self.data = text
        if not text.endswith("\n"):
            text += "\n"
        self.lexer.input(text)
        # PLY takes tokens from self.lexer.lex
        return self._parser.parse(lexer=self.lexer.lex, debug=self.debug)

    # ---------------------- MODULE ----------------------
    # Parse a module: top-level container of statements
    def p_module(self, p):
        """module : statement_list"""
        p[0] = Module(body=p[1], line=1, col=0)


    # ---------------------- STATEMENT LIST ----------------------
    # Parse a list of statements recursively
    # Can be a single statement or multiple statements
    def p_statement_list(self, p):
        """statement_list : statement
                        | statement_list statement"""
        if len(p) == 2:
            p[0] = [p[1]]
        else:
            p[0] = p[1] + [p[2]]

    # ERRORS
    def p_error(self, t):
        if t is None:
            self.errors.append(
                Error(
                    "Unexpected end of input while parsing", 0, 0, "parser", self.data
                )
            )
            return
        # Record the error
        self.errors.append(
            Error(
                f"Syntax error near '{t.value}'",
                t.lineno,
                t.lexpos,
                "parser",
                self.data,
            )
        )
        raise SyntaxError(self.errors[-1].exact())

    # Parse a generic statement: can be simple or compound
    def p_statement(self, p):
        """statement : simple_statement
                    | compound_statement"""
        p[0] = p[1]
    
    # Parse a simple statement, delegates to small_stmt
    def p_simple_statement(self, p):
        """simple_statement : small_stmt"""
        p[0] = p[1]
    
    # Parse the smallest unit of a statement
    # Can be assignment, return, break, continue, pass, or expression
    def p_small_stmt(self, p):
        """small_stmt : assignment
                  | return_stmt
                  | break_stmt
                  | continue_stmt
                  | pass_stmt
                  | expr"""
        
        if len(p) == 2:
            if hasattr(p[1], '__class__') and not isinstance(p[1], (Assign, Return, Break, Continue, Pass)):
                line, col = _pos(p, 1)
                p[0] = ExprStmt(value=p[1], line=line, col=col)
            else:
                p[0] = p[1]


    # ********************************************** Rules for expressions *******************************

    # It handles the basic components of an expression (such as numbers, strings), atoms.
    def p_expr_atom(self, p):
        "expr : atom"
        p[0] = p[1]

    # This rule handles expressions grouped in parentheses. Parentheses do not appear in the AST,
    # pruning is performed.
    def p_expr_group(self, p):
        "expr : LPAREN expr RPAREN"
        p[0] = p[2]

    # ----------------------literals------------------------------------
    # These rules define how to construct nodes for literals in the AST,
    # such as numbers, strings, True, False, and None.
    def p_atom_number(self, p):
        "atom : NUMBER"
        line, col = _pos(p, 1)
        p[0] = LiteralExpr(value=p[1], line=line, col=col)

    def p_atom_string(self, p):
        "atom : STRING"
        line, col = _pos(p, 1)
        p[0] = LiteralExpr(value=p[1], line=line, col=col)

    def p_atom_true(self, p):
        "atom : TRUE"
        line, col = _pos(p, 1)
        p[0] = LiteralExpr(value=True, line=line, col=col)

    def p_atom_false(self, p):
        "atom : FALSE"
        line, col = _pos(p, 1)
        p[0] = LiteralExpr(value=False, line=line, col=col)

    def p_atom_none(self, p):
        "atom : NONE"
        line, col = _pos(p, 1)
        p[0] = LiteralExpr(value=None, line=line, col=col)

    # Recognizes an isolated identifier as an atom (the simplest element in a expression).
    def p_atom_identifier(self, p):
        "atom : ID"
        line, col = _pos(p, 1)
        p[0] = Identifier(name=p[1], line=line, col=col)

    # ----- List, Tuples, Dictionaries -----
    def p_atom_paren(self, p):
        """atom : LPAREN elements_opt RPAREN"""
        line, col = _pos(p, 1)
        elements = p[2]  # list of expressions (may be empty)
        # If it's a single element *without* trailing comma it's still parsed here,
        # but in our grammar the presence/absence of comma is not exposed; treat (x) as x
        # To preserve semantics: if expr_list_opt returned exactly one element, we return that element (parenthesized)
        if len(elements) == 1:
            p[0] = elements[0]
        else:
            p[0] = TupleExpr(elements=elements, line=line, col=col)

    def p_atom_list(self, p):
        """atom : LBRACKET elements_opt RBRACKET"""
        line, col = _pos(p, 1)
        p[0] = ListExpr(elements=p[2], line=line, col=col)

    def p_atom_dict(self, p):
        """atom : LBRACE key_value_list_opt RBRACE"""
        line, col = _pos(p, 1)
        p[0] = DictExpr(pairs=p[2], line=line, col=col)

    # ----------------------Unary------------------------------------
    # These rules define how nodes are constructed for unary operators such as +x, -x, not x.
    def p_expr_unary_plus(self, p):
        "expr : PLUS expr %prec UPLUS"
        line, col = _pos(p, 1)
        # Usamos el tipo de token como op; si prefieres, puedes mapear a "+"
        p[0] = UnaryExpr(op="PLUS", operand=p[2], line=line, col=col)

    def p_expr_unary_minus(self, p):
        "expr : MINUS expr %prec UMINUS"
        line, col = _pos(p, 1)
        p[0] = UnaryExpr(op="MINUS", operand=p[2], line=line, col=col)

    def p_expr_unary_not(self, p):
        "expr : NOT expr"
        line, col = _pos(p, 1)
        p[0] = UnaryExpr(op="NOT", operand=p[2], line=line, col=col)

    # ----------------------Binary------------------------------------
    # These rules handle binary operators for exponentiation, multiplication, and addition.
    def p_expr_power(self, p):
        "expr : expr POWER expr %prec POWER"
        line, col = _pos(p, 1)
        p[0] = BinaryExpr(left=p[1], op="**", right=p[3], line=line, col=col)

    # expr * expr, expr / expr, expr // expr, expr % expr
    def p_expr_multiplicative(self, p):
        """expr : expr TIMES expr
        | expr DIVIDE expr
        | expr FLOOR_DIVIDE expr
        | expr MOD expr"""
        line, col = _pos(p, 1)
        p[0] = BinaryExpr(left=p[1], op=p[2], right=p[3], line=line, col=col)

    # expr + expr, expr - expr
    def p_expr_additive(self, p):
        """expr : expr PLUS expr
        | expr MINUS expr"""
        line, col = _pos(p, 1)
        p[0] = BinaryExpr(left=p[1], op=p[2], right=p[3], line=line, col=col)

    # ----------------------comparisons------------------------------------
    # This rule handles comparisons between expressions.
    # expr == expr, expr != expr, expr < expr, expr <= expr, expr > expr, expr >= expr ----
    def p_expr_comparison(self, p):
        """expr : expr EQUALS expr
        | expr NOT_EQUALS expr
        | expr LESS_THAN expr
        | expr LESS_THAN_EQUALS expr
        | expr GREATER_THAN expr
        | expr GREATER_THAN_EQUALS expr"""
        line, col = _pos(p, 1)
        p[0] = ComparisonExpr(left=p[1], op=p[2], right=p[3], line=line, col=col)

    # ----------------------logical------------------------------------
    # This rule handles logical operators.
    # expr and expr, expr or expr ----
    def p_expr_logical(self, p):
        """expr : expr AND expr
        | expr OR expr"""
        line, col = _pos(p, 1)
        p[0] = BinaryExpr(left=p[1], op=p[2], right=p[3], line=line, col=col)

    # ----------------------Function calls------------------------------------
    # This rule handles function calls
    # Function: f(a, b, c) ----
    def p_expr_call(self, p):
        "expr : ID LPAREN arg_list_opt RPAREN"
        line, col = _pos(p, 1)
        p[0] = CallExpr(
            callee=Identifier(name=p[1], line=line, col=col),
            args=p[3],
            line=line,
            col=col,
        )

    # ----------------------recursive list arg------------------------------------
    # Define one or more expressions separated by commas: a, a, b, a, b, c,...
    # Use right recursion.
    def p_arg_list_opt(self, p):
        """arg_list_opt : expr COMMA arg_list_opt
        | expr"""
        if len(p) == 2:
            p[0] = [p[1]]
        else:
            p[0] = [p[1]] + p[3]

    def p_arg_list_opt_empty(self, p):
        "arg_list_opt :"
        p[0] = []

    def p_empty(self, p):
        "empty :"
        p[0] = []
    
 # ----- Dictionaries -----
    def p_key_value_list(self, p):
        """key_value_list : key_value
                        | key_value COMMA key_value_list"""
        if len(p) == 2:
            p[0] = [p[1]]
        else:
            p[0] = [p[1]] + p[3]

    def p_key_value_list_opt(self, p):
        """key_value_list_opt : key_value_list
                            | empty"""
        p[0] = p[1]

    def p_key_value(self, p):
        "key_value : expr COLON expr"
        p[0] = (p[1], p[3])

        
    # ----- List elements -----
    def p_elements(self, p):
        """elements : expr
                    | elements COMMA expr"""
        if len(p) == 2:
            p[0] = [p[1]]
        else:
            p[0] = p[1] + [p[3]]

    def p_elements_opt(self, p):
        """elements_opt : elements
                        | empty"""
        p[0] = p[1] if len(p) > 1 else []



    # ---------------------- ASSIGNMENTS ----------------------

    # Handles: a = b = c = 0   and   a, b = 1, 2
    def p_assignment(self, p):
        """assignment : assign_targets ASSIGN expr
                    | assign_targets PLUS_ASSIGN expr
                    | assign_targets MINUS_ASSIGN expr
                    | assign_targets TIMES_ASSIGN expr
                    | assign_targets DIVIDE_ASSIGN expr
                    | assign_targets FLOOR_DIVIDE_ASSIGN expr
                    | assign_targets MOD_ASSIGN expr
                    | assign_targets POWER_ASSIGN expr"""
        value = p[3]
        line, col = _pos(p, 1)
        for target in reversed(p[1]):
            # p[2] contiene el operador ('=', '+=', '-=', etc.)
            value = Assign(target=target, op=p[2], value=value, line=line, col=col)
        p[0] = value

    def p_assign_targets(self, p):
        """assign_targets : assign_targets ASSIGN target
                          | target"""
        if len(p) == 2:
            p[0] = [p[1]]
        else:
            p[0] = p[1] + [p[3]]

    def p_target(self, p):
        """target : ID
                  | LPAREN elements_opt RPAREN
                  | LBRACKET elements_opt RBRACKET"""
        if len(p) == 2:
            line, col = _pos(p, 1)
            p[0] = Identifier(name=p[1], line=line, col=col)
        else:
            line, col = _pos(p, 1)
            if p[1] == "(":
                p[0] = TupleExpr(elements=p[2], line=line, col=col)
            else:
                p[0] = ListExpr(elements=p[2], line=line, col=col)
        

    # return
    def p_return_stmt(self, p):
        """return_stmt : RETURN expr
                       | RETURN"""
        if len(p) == 3:
            p[0] = Return(value=p[2])
        else:
            p[0] = Return(value=None)

    # break
    def p_break_stmt(self, p):
        "break_stmt : BREAK"
        p[0] = Break()

    # continue
    def p_continue_stmt(self, p):
        "continue_stmt : CONTINUE"
        p[0] = Continue()

    # pass
    def p_pass_stmt(self, p):
        "pass_stmt : PASS"
        p[0] = Pass()

    # ---------------------- COMPOUND STATEMENTS ----------------------
    # Parse a compound statement: if, while, for, function, or class
    def p_compound_statement(self, p):
        """compound_statement : if_stmt
                          | while_stmt
                          | for_stmt
                          | funcdef
                          | classdef"""
        p[0] = p[1]


    # ---------------------- IF / ELIF / ELSE ----------------------
    # Parse an if statement with optional elif and else blocks
    def p_if_stmt(self, p):
        """if_stmt : IF expr COLON suite elif_blocks else_block_opt"""
        p[0] = If(cond=p[2], body=p[4], elifs=p[5], orelse=p[6])

    # Parse zero or more elif blocks
    def p_elif_blocks(self, p):
        """elif_blocks : ELIF expr COLON suite elif_blocks
                       |"""
        if len(p) == 1:
            p[0] = []
        else:
            p[0] = [(p[2], p[4])] + p[5]

    # Parse an optional else block
    def p_else_block_opt(self, p):
        """else_block_opt : ELSE COLON suite
                          |"""
        p[0] = p[3] if len(p) > 1 else None

    # ---------------------- WHILE ----------------------
    # Parse a while loop statement
    def p_while_stmt(self, p):
        """while_stmt : WHILE expr COLON suite"""
        p[0] = While(cond=p[2], body=p[4])


    # ---------------------- FOR ----------------------
    # Parse a for loop statement
    def p_for_stmt(self, p):
        """for_stmt : FOR ID IN expr COLON suite"""
        line, col = _pos(p, 2)
        p[0] = For(
            target=Identifier(name=p[2], line=line, col=col),
            iterable=p[4],
            body=p[6],
        )

    # ---------------------- SUITE (BLOCKS) ----------------------
    # Parse a suite of statements: single statement or indented block
    def p_suite(self, p):
        """suite : simple_statement
                 | INDENT statement_list DEDENT"""
        if len(p) == 2:
            stmt = p[1]
            p[0] = Block(statements=[stmt], line=getattr(stmt, "line", None), col=getattr(stmt, "col", None))
        else:
            stmts = p[2]
            if stmts:
                p[0] = Block(statements=stmts, line=getattr(stmts[0], "line", None), col=getattr(stmts[0], "col", None))
            else:
                p[0] = Block(statements=[])

    # ********************************************** Rules for Definitions *******************************

    def p_funcdef(self, p):
        "funcdef : DEF ID LPAREN param_list_opt RPAREN COLON statement_list"
        line, col = _pos(p, 1)
        body = Block(statements=p[7]) if not isinstance(p[7], Block) else p[7]
        p[0] = FunctionDef(name=p[2], params=p[4], body=body, line=line, col=col)

    def p_classdef(self, p):
        "classdef : CLASS ID COLON statement_list"
        line, col = _pos(p, 1)
        body = Block(statements=p[3]) if not isinstance(p[3], Block) else p[3]
        p[0] = ClassDef(name=p[2], body=body, line=line, col=col)

    def p_param_list_opt(self, p):
        """param_list_opt : param COMMA param_list_opt
        | param
        |"""
        if len(p) == 1:  # empty
            p[0] = []
        elif len(p) == 2:  # single param
            p[0] = [p[1]]
        else:  # param COMMA param_list_opt
            p[0] = [p[1]] + p[3]

    def p_param(self, p):
        """param : ID"""
        line, col = _pos(p, 1)
        p[0] = Identifier(name=p[1], line=line, col=col)

